GET _cluster/health
GET _cat/indices?v
GET _cat/nodes?v
GET _cat/shards
GET _cat/shards/tmdb-new
GET _cat/recovery

#splitting
PUT tmdb-new/_settings
{
  "settings":{
    "index.blocks.write": true
  }
}

PUT tmdb-new/_split/tmdb-split-2
{
  "settings":{
    "index.number_of_shards": 4
  }
}

#reindexes
POST tmdb-new/_update_by_query
#merges segments
POST tmdb-new/_forcemerge
DELETE tmdb-scaled-2

GET tmdb-scaled/_settings
GET tmdb/_settings
GET tmdb-new/_settings
#shrinking
# make sure all the source index's shards are in the same node and its is read only
PUT /tmdb-scaled/_settings
{
  "settings": {
    "index.number_of_replicas": 0,                                
    "index.routing.allocation.require._name": "preethi-sadagopan", 
    "index.blocks.write": true                                    
  }
}

# shrink it now
PUT tmdb-scaled/_shrink/tmdb-new
{
  "settings":{
        "index.number_of_replicas": 1,
    "index.number_of_shards": 1, 
    "index.codec": "best_compression"
  
  }
}

GET _cluster/health/tmdb-sc?wait_for_no_relocating_shards=true

PUT /tmdb-new/_settings
{
  "settings": {
    "index.number_of_replicas": 2,
    "index.routing.allocation.require._name": null
  }
}

# make node ineligbile for voting, this is done when shutting down 1 node when there are only 2 nodes in the cluster
POST /_cluster/voting_config_exclusions?node_names=node-3


#create snapshot repository
PUT /_snapshot/tmdb-backup
{
  "type": "fs",
  "settings": {
    "location": "/usr/local/var/lib/elasticsearch/backups"
  }
}

#take snapshot
PUT /_snapshot/tmdb-backup/snapshot_1?wait_for_completion=true
{
  "indices": "tmdb,tmdb-new",
  "ignore_unavailable": true,
  "include_global_state": false,
  "metadata": {
    "taken_by": "Preethi",
    "taken_because": "backup before upgrading"
  }
}

#restore snapshot
POST /_snapshot/tmdb-backup/snapshot_1/_restore
{
  "indices": "tmdb",
  "ignore_unavailable": true,
  "include_global_state": false,              
  "rename_pattern": "tmdb",
  "rename_replacement": "tmdb-restored",
  "include_aliases": false
}

GET /tmdb-restored/_count


#create doc with autogenerated id
POST products/_doc
{
  "name": "dalda"
}

#will replace the entire doc with given object or creates a doc with this id
PUT products/_doc/1
{
  "name": "tata salt"
}
GET products/_search

#update certain fields of the doc and will fail if no doc exists with the given id
POST products/_update/1
{
  "doc": {
    "name": "tata iodine salt",
    "price": 15
  }
}

POST products/_doc/2
{
  
    "name": "levista instant coffee",
    "price": 6
  
}

#scripted updates
# with params
POST products/_update/1
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }
    """,
    "params": {
      "inflation_value": 4
    }
    
  }
}

#with noop - notice that version is not increased when noops but otherwise increased even without change
POST products/_update/2
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }else{
       ctx.op = "noop"
     }
    """,
    "params": {
      "inflation_value": 4
    }
    
  }
}

#with ops as delete - this will delete the doc. in real life, it is not useful since you can always use delete by query
POST products/_update/2
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }else{
       ctx.op = "delete"
     }
    """,
    "params": {
      "inflation_value": 4
    }
    
  }
}

#Upserts
#will update only given values if doc is present or will create a new doc with object given in upsert section
POST products/_update/4
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }else{
       ctx.op = "noop"
     }
    """,
    "params": {
      "inflation_value": 4
    }
  },
  "upsert": {
    "name": "pazham pori",
    "price": 2,
    "ingredients": [
      "kadalai mavu",
      "nendra pazham"
    ]
  }
}

DELETE products/_doc/4

GET products/_doc/5

# Primary term and Sequence Number - Optimistic concurrency control
#	Each doc can have different primary term and sequence number
#		doc1 - pt 1 sn 1 (update doc1)
#		doc2 -pt 1 sn 2 (update doc2)
#		doc1 - pt 1 sn 3 (update doc1)
#		doc2 - pt1 sn 4 ( this request would go through with concurrency control only if if_primary_term=1&if_seq_no=2 (would fail if if_seq_no=3)
#	basically these values are incremented across write operations but used for concurrency check at doc level
POST products/_doc/5?if_primary_term=1&if_seq_no=43
{
  "name": "nei appam",
  "price": 7.56
}

GET tmdb-restored/_doc/9779

POST tmdb-restored/_update/9779
{
  "doc":{
  "rotten_tomatoes_rating": 1000
  }
}

#update by query
# 1 batch = 1000 docs by default
POST tmdb-restored/_update_by_query
{
  "script": {
    "source": "ctx._source.rotten_tomatoes_rating = ctx._source_vote_average"
  },
  "query": {
    "match_all": {}
  }
}

#delete by query
POST tmdb-restored/_delete_by_query
{
  "query":{
    "match":{
        "_id": 9779

    }
  }
}

#bulk apis - timeout is set at request level i guess
POST products/_bulk
{ "create": {"_id": 6}}
{ "name": "saunf", "price": 10}
{ "index": { "_id": 7}}
{ "name": "cashew", "price": 50}
{ "create": { "_id": 7}}
{ "name": "cashew 2", "price": 50}
{ "update": { "_id": 7}}
{ "doc": {"name": "cashew kaju", "price": 50}}
{ "delete": { "_id": 1}}

GET products/_doc/7


#===============================MAPPING AND ANALYSIS===========
POST /_analyze
{
  "text": "2   guys walk into   a bar, but the third... DUCKS! !@#",
  "analyzer": "standard"
}

POST /_analyze
{
  "text": "2 guys walk into   a bar, but the third... DUCKS! !@#",
  "char_filter": [],
  "tokenizer": "standard", 
  "filter": ["lowercase"]
 
}
#keyword analyzer
POST /_analyze
{
  "text": "2   guys walk into   a bar, but the third... DUCKS! !@#",
  "analyzer": "keyword"
}

POST coersion_test/_doc/1
{
  "price": "7.59",
  "tags": ["abc", "def"],
  "mixed_tags": ["win", "matches"],
  "another_mixed_tags": [4, 5, 6]
}
POST coersion_test/_doc/3
{
  "price": "7.59",
  "tags": ["abc", "def"],
  "mixed_tags": ["win", "4", "matches"],
  "another_mixed_tags": [4, 5, 6, "7"],
  "nested_array": [1, [2, 3]],
  "nested_string_array": ["abc", ["def", "ghi"]] 
}

GET coersion_test/_mapping
GET coersion_test/_doc/2

#text array indexed as single string, note the 2nd term's offset
POST /_analyze
{
  "text": ["abc", "def"],
  "analyzer": "standard"
}
#this will fail though
POST /_analyze
{
  "text": ["abc", ["def"]],
  "analyzer": "standard"
}

DELETE reviews
#create mapping. array of keywords data type is also just keyword only, notice tags
PUT /reviews
{
  "mappings": {
    "properties": {
      "rating": {
        "type": "float"
      },
      "content": {
        "type": "text"
      },
      "product_id": {
        "type": "text"
      },
      "tags": {
        "type": "keyword"
      },
      "author": {
        "properties": {
          "first_name": {"type": "text"},
          "last_name": {"type": "text"},
          "email": {"type": "keyword"}
        }
      }
    }
  }
}

PUT /reviews/_doc/1
{
  "rating": 5.7,
  "content": "okayish food",
  "product_id": "ABC",
  "author": {
    "first_name": "Preethi",
    "last_name": "Ram",
    "email": "a@a.com"
  },
  "likes": [{
    "by": "Mamtha Soni",
    "vote": "UP"
  },
  {
    "by": "Borris Johnson",
    "vote": "UP"
  }]
}

PUT /reviews/_doc/2
{
  "rating": 8.7,
  "content": "amazing food",
  "product_id": "Burma burma",
  "author": {
    "first_name": "Steve",
    "last_name": "Carell",
    "email": "s@c.com"
  },
  "tags": [
    "thai",
    "asian veg"
  ],
  "rating_history": [
    7,
    6,
    9
  ],
  "test_float_array": [
    7.4,
    4.2,
    3
  ],
  "likes": [
    {
      "by": "Voldemort",
      "vote": "UP"
    },
    {
      "by": "Aaron Bolt",
      "vote": "UP"
    },
    {
      "by": "Mamtha Venkat",
      "vote": "UP"
    }
  ]
}

PUT /reviews/_doc/3
{
  "rating": 5,
  "content": "not worthy food",
  "product_id": "Beijing bites",
  "author": {
    "first_name": "Steve",
    "last_name": "Carell",
    "email": "s@c.com"
  },
  "tags": [
    "chinese",
    "asian veg"
  ],
  "rating_history": [
    4,
    6,
    3
  ],
  "test_float_array": [
    7.4,
    4.2,
    3
  ],
  "likes": [
    {
      "by": "Phoebe Buffay",
      "vote": "DOWN"
    },
    {
      "by": "Ross Geller",
      "vote": "DOWN"
    },
    {
      "by": "Chandeler Bing",
      "vote": "UP"
    }
  ]
}

GET /reviews/_mapping
GET /reviews/_mapping/field/likes.by
GET /reviews/_doc/1


#updates mapping, can specify existing field in mapping with same value but will fail if the new change requires any kind of reindexing exmaple product_id can't be changed from text to keyword since it has to analyse already stored docs
PUT /reviews/_mapping
{
  "properties": {
    "rating":{ "type": "float"},
    "product_id": {"type": "keyword"},
    "likes1": {
      "type": "nested",
      "properties": {
        "by": {
          "type": "text"
        },
        "vote": {
          "type": "text"
        }
      }
    }
  }
}

#disable coerce
PUT /reviews/_mapping
{
  "properties":{
    "rating": {
      "type": "float",
      "coerce": false
    }
  }
}
GET /reviews/_doc/1

#this will fail since coerce is disabled
POST /reviews/_update/1
{
  "doc":{
  "rating": "7.5"
  }
}

# multi field mappings  where likes.by is used for text search and likes.by.keyword is used for sorting. Try using likes.by for sorting, it will throw error since text cannot be used for sorting

# from the result, looks like each liked.by even with spaces is stored as 1 term, array of keywords data type is also just keyword only, notice tags
GET /reviews/_search
{
  "query": {
    "match": {
      "likes.by": "mamtha"
    }
  },
  "sort": [
    {
      "likes.by.keyword": {
        "order": "asc",
        "mode": "min"
      }
    }
  ],
  "_source": ["likes.by", "product_id"], 
  "aggs": {
    "likers": {
      "terms": {
        "field": "likes.by.keyword",
        "size": 10
      }
    }
  }
}

GET /_cat/fielddata?v&fields=*

GET tmdb/_search
GET tmdb/_search
{
  "aggs": {
    "max-rating": {
      "max": {
        "field": "vote_count"
      }
    }
  }
}

GET tmdb/_mapping/field/vote_count
PUT tmdb/_mapping
{
  "properties": {
    "vote_count":{
      "type": "long",
      "doc_values": false
      
    }
  }
}


#updating the shard routing identifier
PUT custom-routing-test
{
  "settings": {
    "number_of_shards": 3
  },
  "mappings": {
    "_routing": {"required": true}
  }
}

PUT custom-routing-test/_doc/1?routing=item-1
{ "name": "suyyam", "item_id": "item-1"}

#to know which shard the doc went to
GET custom-routing-test/_search
{
  "explain": true
}
#update routing value, this didn't delete and create doc in new shard, it just creates in new shard.
PUT custom-routing-test/_doc/1?routing=item-2
{ "name": "suyyam", "item_id": "item-2"}
#while searching, duplicate is returned
GET custom-routing-test/_search?q=suyyam

DELETE tmdb-reindexed
GET tmdb/_mapping
PUT tmdb-reindexed
{
  "mappings":{
    "properties":{
      "rating_avg":{"type": "float"}
    }
  }
}
POST _reindex
{
  "script": {
    "source": """
       if(ctx._source.vote_average > 5){
         ctx.op = "index"
       }else{
         //This will delete the existing docs in dest index
         //ctx.op = "delete" 
         
         // this will just skip while indexing, existing docs if any wouldn't be deleted
         ctx.op = "noop" 
       }
       // Rename vote average to rating_avg
       ctx._source.rating_avg = ctx._source.remove("vote_average")
    """
  }, 
  "source": {
    "index": "tmdb"
  },
  "dest":{
    "index": "tmdb-reindexed"
  }
}

GET tmdb-reindexed/_search

#================ index templates

PUT _template/access-logs
{
  "index_patterns": ["access-logs*"], 
  "order": 1, 
  "mappings": {
    "properties": {
      "response.success": {
        "type": "boolean"
      },
      "response.code": {
        "type": "text"
      }
    }
  }
}

PUT _template/access-logs-1
{
  "index_patterns": ["access-logs*"], 
  "order": 3, 
  "aliases": {
    "access-logs": {}
  }, 
  "mappings": {
    "properties": {
      "response.code": {
        "type": "keyword"
      },
      "upstream_ip":{
        "type": "keyword"
      }
    }
  }
}

DELETE access-logs-2021-08
PUT access-logs-2021-08 
{
  "aliases": {
    "access-log-aug": {}
  }

}
GET _template/access-logs
GET access-logs


#new index templates takes precedence over existing old templates
PUT /_index_template/access-logs
{
  "index_patterns": "access-logs*",
  "template":{
        "mappings": {
      "properties":{
      "downstream_ip": {"type": "keyword"}
      }
    },

    "settings":{
      "number_of_shards": 2
    }
  }
}

GET _index_template/access-logs

PUT _component_template/logs-component
{
  "template":{
    "settings":{
      "number_of_shards": 1
    },
    "mappings":{
      "properties":{ "response.code": {"type": "keyword"},
        "upstream_ip":{"type": "text"}
      }
    }
  }
}
#priority will choose a template and doesn't merge the other templates, merging is achieved through composed_of
PUT /_index_template/access-logs-new
{
  "priority": 1,
  "index_patterns": "access-logs*",
  "template":{
    "mappings": {
      "properties":{
      "upstream_ip": {"type": "keyword"}
      }
    },
    "settings":{
      "number_of_shards": 2
    }
  },
  "composed_of": ["logs-component"]
}
DELETE access-logs-2021-09
PUT access-logs-2021-09
GET access-logs-2021-09


#Disable dynamic mapping
# no inverted index is created for fields that doesn't have mapping and the field is ignore but woul dbe present in _source
PUT /disable-dynamic-mapping-test
{
  "mappings": {
    "dynamic": false,
    "properties": {"first_name": {"type": "text"}}}
}

PUT /disable-dynamic-mapping-test/_doc/1 
{"first_name": "Preethi", "last_name": "Ram"}

GET disable-dynamic-mapping-test/_doc/1

#search by non mapped field doesn't yield results because it is not indexed
GET disable-dynamic-mapping-test/_search
{"query": {"match": {
  "last_name": "Ram"
}}}

PUT /disable-dynamic-mapping-test/_mapping
{
  
    "dynamic": "strict",
    "properties": {"first_name": {"type": "text"}}
}

#strict will not allow unmapped fields and fail
PUT /disable-dynamic-mapping-test/_doc/1 
{"first_name": "Preethi", "last_name": "Ram"}


#dynamic templates
DELETE /dynamic-template-test

#dynamic mappings are matched in specified order and breaks when one match is found
PUT /dynamic-template-test
{
  "mappings": {
    "properties": {
      "full_address": {
        "type": "text",
        "store": true
      }
    },
    "dynamic_templates": [
      {
        "copy_to_address": {
          "match_mapping_type": "string",
          "path_match": "address.*",
          "mapping": {
            "type": "text",
            "copy_to": "full_address"
          }
        }
      },
      {
        "no_norm_values": {
          "match_mapping_type": "*",
          "mapping": {
            "type": "{dynamic_type}",
            "norms": false
          }
        }
      },
      {
        "string_with_only_text": {
          "match_mapping_type": "string",
          "match": "*",
          "unmatch": "*keyword",
          "mapping": {
            "type": "text"
          }
        }
      },
      {
        "string_with_only_keyword": {
          "match_mapping_type": "string",
          "match": "*keyword",
          "mapping": {
            "type": "keyword"
          }
        }
      }
    ]
  }
}

PUT /dynamic-template-test/_doc/1
{
  "name": "Preethi",
  "course_keyword": "Btech",
  "address": {
    "street": "elango street",
    "nagar": "prakash nagar",
    "pincode": "602024"
  }
}

GET dynamic-template-test/_mapping
GET /dynamic-template-test/_search
{
  "stored_fields": ["full_address"]
}

#Analyzers
GET tmdb/_settings

DELETE products-using-analyzer
PUT products-using-analyzer
{
  "mappings":{
    "properties":{
      "description": {
        "type": "text",
        "analyzer": "remove_english_stop_words"
      },
      "name":{
        "type": "text",
        "analyzer": "english"
      }
    }
  },
  "settings": {
    "analysis": {
      "analyzer": {
        "remove_english_stop_words":{
          "type": "standard",
          "stopwords": "_english_"
        }
      }
    }
  }
  }
POST products-using-analyzer/_doc/1
{
  "name": "Wolf of the wall street",
  "description": "This is based on John's life"
}

GET products-using-analyzer/_search
{
  "query": {
    "match": {
      "name": "Wolf wall"
    }
  }
}

#testing analyzer
POST _analyze
{
  "text": "This is based on the John's life",
  "analyzer": "standard"
}

POST products-using-analyzer/_analyze
{
  "text": "This is based on the John's life",
  "field": "description"
}

POST products-using-analyzer/_analyze
{
  "text": "This is based on the John's life",
  "field": "name"
}


POST _analyze
{
  "char_filter": ["html_strip"], 
  "text": "<bold>I'm a strong player, I'm playing guitar now. He jumped in joy </bold>",
  "tokenizer": "standard"
  , "filter": ["lowercase", "stemmer", "stop"]
}

POST _analyze
{
  "text": "I'm a strong player, I'm playing guitar now. He jumped in joy. Les Misérables",
  "char_filter": [
    {
      "type": "mapping",
      "mappings": [
        "'=>"
      ]
    }
  ],
  "tokenizer": "standard",
  "filter": [
    "asciifolding",
    {
      "type": "edge_ngram",
      "min_gram": 2,
      "max_gram": 10
    }
  ]
}

POST _analyze
{
  "text": "I'm a strong player, I'm playing guitar now. He jumped in joy",
  "tokenizer": {
    "type": "edge_ngram",
    "min_gram": 2,
    "max_gram": 10
  }
}

DELETE movies-using-custom-analyzer
PUT movies-using-custom-analyzer
{
  "settings": {
    "analysis": {
      "char_filter": {
        "remove_apostrophe": {
          "type": "mapping",
          "mappings": [
            "'=>"
          ]
        }
      },
      "filter": {
        "my-edge-ngram-token-filter": {
          "type": "edge_ngram",
          "min_gram": 2,
          "max_gram": 10
        }
      },
      "analyzer": {
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": [
            "html_strip",
            "remove_apostrophe"
          ],
          "tokenizer": "standard",
          "filter": [
            "asciifolding",
            "lowercase",
            "stop",
            "my-edge-ngram-token-filter"
          ]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "my_custom_analyzer"
      },
      "overview": {
        "type": "text",
        "analyzer": "my_custom_analyzer"
      },
      "directors": {
        "type": "keyword"
      }
    }
  }
}
GET tmdb/_search
POST movies-using-custom-analyzer/_bulk
{"index":{"_id":1}}
{"title":"Les Misérables","overview":"It's summertime, and Greg Heffley is looking forward to playing video games and spending time with his friends. However, Greg's dad has other plans"}
{"index":{"_id":2}}
{"title":"<b>Gangster Squad</b>","overview":"Los Angeles, 1949. Ruthless, Brooklyn-born mob king Mickey Cohen runs the show in this town, reaping the ill-gotten gains from the drugs, the guns, the prostitutes and — if he has his way — every wire bet placed west of Chicago. And he does it all with the protection of not only his own paid goons, but also the police and the politicians who are under his control. It’s enough to intimidate even the bravest, street-hardened cop… except, perhaps, for the small, secret crew of LAPD outsiders led by Sgt. John O’Mara and Jerry Wooters who come together to try to tear Cohen’s world apart."}

#this shouldn't have written any results since gang is not present in overivew for both the docs but it did due to edge ngram used in search analyzer too
POST movies-using-custom-analyzer/_search
{"query":{"match":{"overview":"Gang"}}}

#this returns empty because stop words are removed
POST movies-using-custom-analyzer/_search
{"query":{"match":{"overview":"the"}}}


#gains would be split to ga and above search term Gang would also be split g, ga, gan and the overview is matched. Diff search analyzer should be used
POST movies-using-custom-analyzer/_analyze
{
  "text": "Los Angeles, 1949. Ruthless, Brooklyn-born mob king Mickey Cohen runs the show in this town, reaping the ill-gotten gains from the drugs, the guns, the prostitutes and — if he has his way — every wire bet placed west of Chicago. And he does it all with the protection of not only his own paid goons, but also the police and the politicians who are under his control. It’s enough to intimidate even the bravest, street-hardened cop… except, perhaps, for the small, secret crew of LAPD outsiders led by Sgt. John O’Mara and Jerry Wooters who come together to try to tear Cohen’s world apart."
  , "field": "overview"
}

GET movies-using-custom-analyzer/_settings

#close index to update analyzer
POST movies-using-custom-analyzer/_close

#adds new analyzer and removes stop from existing analyzer
PUT movies-using-custom-analyzer/_settings
{
  "analysis": {
    "analyzer": {
      "my_custom_search_analyzer": {
        "type": "custom",
        "char_filter": [
          "html_strip",
          "remove_apostrophe"
        ],
        "tokenizer": "standard",
        "filter": [
          "asciifolding",
          "lowercase"
        ]
      },
      "my_custom_analyzer": {
        "type": "custom",
        "char_filter": [
          "html_strip",
          "remove_apostrophe"
        ],
        "tokenizer": "standard",
        "filter": [
          "asciifolding",
          "lowercase"
        ]
      }
    }
  }
}

POST movies-using-custom-analyzer/_open

PUT movies-using-custom-analyzer/_mapping
{
  "properties": {
    "title": {
      "type": "text",
      "analyzer": "my_custom_analyzer",
      "search_analyzer": "my_custom_search_analyzer"
    },
    "overview": {
      "type": "text",
      "analyzer": "my_custom_analyzer",
      "search_analyzer": "my_custom_search_analyzer"
    }
  }
}

#search again, this doesn't return docs as expected without reindex because we have changed search analyzer
POST movies-using-custom-analyzer/_search
{"query":{"match":{"overview":"Gang"}}}

#search again, this still didn't work because existing data isn't reindexed
POST movies-using-custom-analyzer/_search
{"query":{"match":{"overview":"the"}}}

#reindexes document
POST movies-using-custom-analyzer/_update_by_query


GET _cat/shards/tmdb-new
#reindexes doc asynchronously
POST tmdb-new/_update_by_query?wait_for_completion=false

GET _tasks/JclyIaT5REyvMyJ_eU1c5g:109220

#now the size would have doubled after update
#merges segments
POST tmdb-new/_forcemerge


#=======================Term search queries==============
GET tmdb/_search?q=title:Gangster Squad AND directors:Hogan
GET tmdb/_search?q=title:Gangster Squad OR directors:Hogan
{
  "explain": true
}

#will yield result since gangster value in the doc would be analysed and indexed after lowercasing
POST movies-using-custom-analyzer/_search 
{
  "query": {
    "term": {
      "title": {
        "value": "gangster"
      }
    }
  }
}

#will not yield result since gangster would be indexed after lowercasing and term queries are not analysed and hence doesn't match
POST movies-using-custom-analyzer/_search 
{
  "query": {
    "term": {
      "title": "Gangster"
    }
  }
}

#will yield result since gangster would be indexed after lowercasing and match query is also analysed
POST movies-using-custom-analyzer/_search 
{
  "query": {
    "match": {
      "title": "Gangster"
    }
  }
}

GET reviews/_search
{
  "query": {
    "prefix": {
      "nam": {
        "value": ""
      }
    }
  }
}

POST reviews/_analyze
{
  "text": "asian veg",
  "field": "content"
}

#multi terms, OR clause, will get doc even if single tag in the query matches with the doc tags.
GET reviews/_search
{
  "explain": true, 
  "query": {
    "terms": {
      "tags": [
        "asian veg",
        "thai"
      ]
    }
  }
}

#fetch by ids
GET reviews/_search
{
  "query": {
    "ids": {
      "values": [1,2,3,4]
    }
  },
  "fields": ["rating", "added_at"],
  "_source": false
}

POST reviews/_update/3 
{
  "doc": {
    "added_at": "2021/03/22"
  }
}

#range query
GET reviews/_search
{
  "query": {
    "range": {
      "rating": {
        "gte": 7,
        "lte": 9
      }
    }
  }
}

GET reviews/_search
{
  "query": {
    "range": {
      "rating": {
        "gt":"5" 
      }
    }
  }
}

#for array, it returns the doc if any value in the field matches the condition
GET reviews/_search
{
  "query": {
    "range": {
      "rating_history": {
        "gte": 8
      }
    }
  }
}

# range queries - date
GET reviews/_search
{
  "query": {
    "range": {
      "added_at": {
        "gte": 2021,
        "format": "yyyy"
      }
    }
  }
}


PUT reviews/_mapping
{
  "properties": {
    "promotion_period_new": {
      "type": "date_range",
      "format": "yyyy-MM-dd'T'HH:mm:ss"
    }
  }
}

GET reviews/_mapping

POST reviews/_update/1
{
  "doc": {
    "promotion_period_new": {
      "gte": "2021-01-15T00:00:00",
      "lte": "2021-04-12T23:59:59"
    }
  }
}
POST reviews/_update/2
{
  "doc": {
    "promotion_period_new": {
      "gte": "2021-02-15T00:00:00",
      "lte": "2021-05-12T23:59:59"
    }
  }
}
POST reviews/_update/3
{
  "doc": {
    "promotion_period_new": {
      "gte": "2021-03-15T00:00:00",
      "lte": "2021-06-12T23:59:59"
    }
  }
}

# real life case - used to fetch all promotions running in the given range

#range queries - date range
#intersects (default) - any overlap
# |qurey range-----<doc |---range> ----|
GET reviews/_search
{
  "query": {
    "range": {
      "promotion_period_new": {
        "gte": "2021-01-15",
        "lte": "2021-02-29",
        "format": "yyyy-MM-dd",
        "relation": "intersects"
        
      }
    }
  },
  "fields": ["promotion_period_new"],
  "_source": "false"
}

#range queries - date range
#contains - doc with range that entirely contains the query range
# |qurey range-----<doc range> ----|
GET reviews/_search
{
  "query": {
    "range": {
      "promotion_period_new": {
        "gte": "2021-01-15",
        "lte": "2021-02-29",
        "format": "yyyy-MM-dd",
        "relation": "contains"
      }
    }
  },
  "fields": ["promotion_period_new"],
  "_source": "false"
}

#range queries - date range
#within - doc with range that entirely fits within the query range
# |Doc range-----<query range> ----|
GET reviews/_search
{
  "query": {
    "range": {
      "promotion_period_new": {
        "gte": "2021-01-15",
        "lte": "2021-04-29",
        "format": "yyyy-MM-dd",
        "relation": "within"
      }
    }
  },
  "fields": ["promotion_period_new"],
  "_source": "false"
}

#Date math
GET reviews/_search
{
  "query": {
    "range": {
      "added_at": {
        "gte": "now-1y-5M"
      }
    }
  },
  "fields": ["added_at"],
  "_source": "false"
}

PUT /reviews/_doc/4
{
  "rating": 8,
  "content": "amazing food",
  "product_id": "Chianti",
  "author": {
    "first_name": "Jim",
    "last_name": "Halplert",
    "email": "s@c.com"
  },
  "tags": [
    "italian"
  ],
  "rating_history": [
    8,
    9,
    9
  ],
  "test_float_array": [
    4,
    4.2,
    3
  ],
  "likes": [
    {
      "by": "Voldemort",
      "vote": "UP"
    }
  ],
  "promotion_period_new": {
    "gte": "2022-03-01T00:00:00"
    
  }
}


GET reviews/_search
{
  "query": {
    "range": {
      "promotion_period_new": {
        "gte": "2021-05-21",
        "lte": "2021-05-21||+1h/d",
        "format": "yyyy-MM-dd"
      }
    }
  },
  "fields": ["promotion_period_new"],
  "_source": "false"
}

POST reviews/_update/4
{"doc":{"tags":[]}}

POST reviews/_update/1
{"doc": {"test_empty": ""}}
POST reviews/_update/2
{"doc": {"test_empty": "i'm not empty"}}

#non null
# for string, empty string is considered as exist
# for array,empty array is not considered as exist
# if null_value parameter used, docs will not return in exist
GET /reviews/_search
{
  "query": {
    "exists": {
      "field": "tags"
    }
  }
}

#prefix queries
GET /reviews/_search
{"query":{"prefix":{"tags":"asi"}}}

#remember that tag is a keyword and are indexed as is. so asian veg is indexed as single term and not as two terms
GET /reviews/_search
{"query":{"prefix":{"tags":"ve"}}}

GET tmdb/_mapping/field/directors

POST tmdb/_analyze
{ "text": ["David Bowers"], "field": "directors"}

#since directors is not a keyword and indexed as text, prefix with just bow for "David Bowers" also matches the doc
GET tmdb/_search
{"query":{"prefix":{"directors":{"value":"bow"}}}} 

#wildcard
GET tmdb/_search
{"query":{"wildcard":{"directors":"ste*"}}}

#regexp
#note the smaller case d because thats how it is indexed
GET tmdb/_search
{"query":{"regexp":{"directors":  "da[a-zA-z]+d"}}}

#================Full text search==================
# multiple terms trial
PUT terms-test/_doc/1
{ "name": "Potato salad is the best one", "description": "its a good one"}
PUT terms-test/_doc/2
{ "name": "Greek salad", "description": "this salad is good for dieting"}
PUT terms-test/_doc/3
{ "name": "Potato fries goes well with burger", "description": "well the name says it all"}
PUT terms-test/_doc/3
{ "name": "Potato fries goes well with burger", "description": "well the name says it all"}


#default operator is or. it matches with docs that has any of the terms specified. Rememeber the query is also analyzed and borken down
GET terms-test/_search
{
  "query": {
    "match": {
      "name": "potato or fries"
    }
  }
}

#operator and specifies that all terms int eh query should be present in the doc
GET terms-test/_search
{
  "query": {
    "match": {
      "name": {
       "query": "fries potato",
       "operator": "and"
      }
    }
  }
}

#matches sequence of words
# wouldn't match fries potato
GET terms-test/_search
{
  "query": {
    "match_phrase": {
      "name": {
       "query": "potato fries"
      }
    }
  }
}

#matches same sequence of words with the last term treated as prefix of next word  
GET terms-test/_search
{
  "query": {
    "match_phrase_prefix": {
      "name": {
       "query": "fries goes w"
      }
    }
  }
}
  
# this will not match anything since the last term is considered as the whole term and not prefix  
GET terms-test/_search
{
  "query": {
    "match_phrase": {
      "name": {
       "query": "fries goes w"
      }
    }
  }
}

#multi match
# Remember each field has a separate index
GET terms-test/_search
{
  "query": {
    "multi_match": {
      "query": " salad",
      "fields": [
        "name",
        "description"
      ]
    }
  }
}

#multi match with 2 terms
# note both good and salad is present in description field of greek salad and only salad is present in name of greek salad. doc relevance = max relevance of both fields. use explain= true to know more
GET terms-test/_search
{
  "query": {
    "multi_match": {
      "query": "good salad",
      "fields": ["name", "description"]
    }
  }
}

#===== compound queries======
GET recipes/_search
{
  "size": 25, 
  "query": {"match_all": {}},
  "fields": ["title", "ingredients.name"],
  "_source": "false"
}
GET recipes/_mapping/field/ingredients.name

#must
GET recipes/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "pasta"
          }
        },
        {
          "range": {
            "servings.max": {
              "lte": 4
            }
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "ingredients.name": "whole wheat"
          }
        },
        {
          "match": {
            "ingredients.name": "beef"
          }
        }
      ],
      "should": [
        {
          "match": {
            "ingredients.name": "fusilli"
          }
        }
      ],
      "filter": [
        {
          "range": {
            "preparation_time_minutes": {
              "gte": 20
            }
          }
        }
      ]
    }
  },
  "_source": {
    "excludes": [
      "description",
      "steps",
      "ingredients.quantity"
    ]
  }
}

#notice that must is an object since it has only one condition
GET recipes/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "title": "pasta"
        }
      },
      "filter": [
        {
          "range": {
            "preparation_time_minutes": {
              "gte": 20
            }
          }
        }
      ]
    }
  },
  "_source": {
    "excludes": [
      "description",
      "steps",
      "ingredients.quantity"
    ]
  }
}

#named queries, notice that only the 1st query has fusilli_should, useful for debugging
GET recipes/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": {
              "query": "pasta",
              "_name": "pasta_must"
            }
          }
        },
        {
          "range": {
            "servings.max": {
              "lte": 4,
              "_name": "max_servings_must"
            }
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "ingredients.name": {
              "query": "whole wheat",
              "_name": "whole_wheat_must_not"
            }
          }
        },
        {
          "match": {
            "ingredients.name": {
              "query": "beef",
              "_name": "beef_must_not"
            }
          }
        }
      ],
      "should": [
        {
          "match": {
            "ingredients.name": {
              "query": "fusilli",
              "_name": "fusilli_should"
            }
          }
        }
      ],
      "filter": [
        {
          "range": {
            "preparation_time_minutes": {
              "gte": 20,
              "_name": "prep_filter"
            }
          }
        }
      ]
    }
  },
  "_source": {
    "excludes": [
      "description",
      "steps",
      "ingredients.quantity"
    ]
  }
}

#default operator is or. it matches with docs that has any of the terms specified. Rememeber the query is also analyzed and borken down
GET terms-test/_search
{
  "query": {
    "match": {
      "name": "potato or fries"
    }
  }
}

#gets translated to
GET terms-test/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "name": "potato"
          }
        },
        {
          "match": {
            "name": "or"
          }
        },
        {
          "match": {
            "name": "fries"
          }
        }
      ]
    }
  }
}

#operator and specifies that all terms int eh query should be present in the doc
GET terms-test/_search
{
  "query": {
    "match": {
      "name": {
       "query": "fries Potato",
       "operator": "and"
      }
    }
  }
}

#gets translated to
# this won't work because P is capital case in potato. In actual scenario, the query is analysed and the resulting terms are translated to term queries like below, so in actual translation, it would be small case p
GET terms-test/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "name": "fries"
          }
        },
        {
          "term": {
            "name": "potato"
          }
        }
      ]
    }
  }
}

#single term match query
# name.keyword would store Potato salad is the best one as single index term
GET terms-test/_search
{
  "query": {
    "match": {
      "name": "Potato"
    }
  }
}

#gets translated to after going through analyzer
GET terms-test/_search
{
  "query": {
    "term": {
      "name": "potato"
    }
  }
}

#==================Join queries===================
PUT /department
{
  "mappings": {  
    "properties": {
      "name": {
        "type": "text"
      },
      "employees": {
        "type": "nested"
      }
    }
  }
}

PUT /department/_doc/1
{
  "name": "Computer science",
  "employees": [
    {"name": "Merlin", "age": 35, "gender": "F", "position": "Professor"},
    {"name": "Shobana", "age": 28, "gender": "F", "position": "Assistant Professor"},
    {"name": "Vishwa", "age": 25, "gender": "M", "position": "Assistant Professor"}]
}

PUT /department/_doc/2
{
  "name": "Chemistry",
  "employees": [
    {"name": "Ganesh", "age": 35, "gender": "M", "position": "Lab Assistant"},
    {"name": "Rishi", "age": 23, "gender": "M", "position": "assistant professor"},
    {"name": "Sathvika", "age": 29, "gender": "F", "position": "Guest Lecturer"},
    {"name": "Aadhirai", "age": 38, "gender": "F", "position": "HOD"}]
}

# querying nested objects
#inner hits also brings in matching employees
GET /department/_search
{
  "query": {
    "nested": {
      "path": "employees",
      "inner_hits": {
        "name": "matched_employees"
      },
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "employees.position": "Professor"
              }
            },
            {
              "range": {
                "employees.age": {
                  "lte": 30
                }
              }
            }
          ],
          "should": [
            {
              "term": {
                "employees.gender.keyword": "F"
              }
            }
          ]
        }
      }
    }
  }
}

# join field
PUT department-joins
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text"
      },
      "join_field": {
        "type": "join",
        "relations": {
          "department": "staff"
        }
      }
    }
  }
}

POST /department-joins/_doc/1
{
  "name": "Computer Science",
  "join_field": "department"
}

POST /department-joins/_doc/2
{
  "name": "Chemistry",
  "join_field": "department"
}

POST /department-joins/_doc/3?routing=1
{
 "name": "Merlin", "age": 35, "gender": "F", "position": "Professor", "join_field":{ "name": "staff", "parent": 1}
}
POST /department-joins/_doc/4?routing=1
{
 "name": "Shobana", "age": 28, "gender": "F", "position": "Assistant Professor", "join_field":{ "name": "staff", "parent": 1}
}
POST /department-joins/_doc/5?routing=1
{
 "name": "Vishwa", "age": 25, "gender": "M", "position": "Assistant Professor", "join_field":{ "name": "staff", "parent": 1}
}

POST /department-joins/_doc/6?routing=2
{"name": "Sathvika", "age": 29, "gender": "F", "position": "Guest Lecturer", 
  "join_field": {"name": "staff", "parent":2}
}

GET /department-joins/_search
{
  "explain": true
}

# query by parent id
GET /department-joins/_search
{
  "query": {
    "parent_id": {
      "type": "staff",
      "id": 2
    }
  }
}

# query child by parent attributes has_parent
GET /department-joins/_search
{
  "query": {
    "has_parent": {
      "parent_type": "department",
      "query": {
        "wildcard": {
          "name": "*"
        }
      }
    }
  },
  "aggs": {
    "employee-avg-age": {
      "avg": {
        "field": "age"
      }
    }
  }
}
# query parent by child attributes has_child, different scoring modes - min, max, sum, avg, none
GET /department-joins/_search
{
  "query": {
    "has_child": {
      "score_mode": "avg", 
      "min_children": 1, 
      "inner_hits": {}, 
      "type": "staff",
      "query": {
        "term": {
          "gender.keyword": "F"
        }
      }
    }
  }
}

# terms lookup 
PUT /terms-lookup-rest/_doc/r1
{
  "name": "KFC indranagar",
  "brand_id": 101
}
PUT /terms-lookup-rest/_doc/r2
{
  "name": "KFC kaggadaspura",
  "brand_id": 101
}
PUT /terms-lookup-rest/_doc/r3
{
  "name": "Madurai cafe, kaggadaspura",
  "brand_id": 102
}

PUT /terms-lookup-brand/_bulk
{"index": { "_id": 101}}
{"name": "KFC", "owned_by": "Johnson"}
{"index": { "_id": 102}}
{"name": "Madurai cafe", "owned_by": "Murugan"}


PUT /terms-lookup-dish/_bulk
{"index": {"_id": 201}}
{"name": "Chicken wings", "brand_id": 101}
{"index": {"_id": 202}}
{"name": "Beef wings", "brand_id": 101}
{"index": {"_id": 203}}
{"name": "Idly vadacurry", "brand_id": 102}

# Get all menu items of brand this resto belongs to
GET /terms-lookup-dish/_search
{
  "query": {
    "terms": {
      "brand_id": {
        "index": "terms-lookup-rest",
        "path": "brand_id",
        "id": "r2"
      }
    }
  }
}

#=====================Controlling query results==========================

#doesn't work
GET recipes/_search?format=yaml
{
  "query": {
    "match_all": {}
  }
}

#useful for curl
GET recipes/_search?pretty
{
  "query": {
    "match_all": {}
  }
}

#size & sort
# used to get just the matches
GET tmdb/_search
{
  "size": 10,
  "from": 0,
  "_source": "title",
  "sort": [
    {
      "_score": "desc"
    },
    {
      "vote_average": "desc"
    },
    {
      "vote_count": "desc"
    }
  ]
}

#mode in sorting
GET reviews/_search
{
  "_source": [
    "rating_history",
    "product_id"
  ],
  "sort": [
    {
      "rating_history": {
        "order": "desc",
        "mode": "max"
      }
    }
  ]
}

#===========================Aggregations=====================
DELETE orders-agg-test
PUT /orders-agg-test
{
  "mappings": {
    "properties": {
      "purchased_at": {
        "type": "date"
      },
      "lines": {
        "type": "nested",
        "properties": {
          "product_id": {
            "type": "integer"
          },
          "amount": {
            "type": "double"
          },
          "quantity": {
            "type": "short"
          }
        }
      },
      "total_amount": {
        "type": "double"
      },
      "status": {
        "type": "keyword"
      },
      "sales_channel": {
        "type": "keyword"
      },
      "salesman": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer"
          },
          "name": {
            "type": "text"
          }
        }
      }
    }
  }
}

#Metric aggregations
#single value - outputs single value
GET orders-agg-test/_search
{
  "size": 0, 
  "aggs": {
    "AOV": {
      "avg": {
        "field": "total_amount"
      }
    },
    "total_sales": {
      "sum": {
        "field": "total_amount"
      }
    },
    "distinct_sales_man": {
      "cardinality": {
        "field": "salesman.id",
        "precision_threshold": 100
      }
    },
    "value_count": {
      "value_count": {
        "field": "total_amount"
      }
    }
  }
}

#stats - multi value
GET orders-agg-test/_search
{
  "size": 0,
  "aggs": {
    "amount_stats": {
      "stats": {
        "field": "total_amount"
      }
    }
  }
}

GET recipes/_mapping/field/ingredients.name.keyword
#Bucket aggregations
#terms aggregation
GET recipes/_search
{
  "size": 0,
  "query": {
    "term": {
      "ingredients.name.keyword": {
        "value": "Kosher salt"
      }
    }
  }, 
  "_source": ["title", "ingredients.name"],
  "aggs": {
    "total-deduplicated-ingredients":{
      "value_count": {
        "field": "ingredients.name.keyword"
      }
    },
    "total-ingredients": {
      "cardinality": {
        "field": "ingredients.name.keyword"
      }
    },
    "top-ingredients":{
      "terms": {
        "field": "ingredients.name.keyword",
        "size": 10
      }
    }
  }
}

PUT recipes/_doc/22
{ "title": "Rasam"}
#low cardinality and high cardinality
#missing, min_doc_count, _order
GET recipes/_search
{
  "size": 0,
  "_source": ["title", "ingredients.name"],
  "aggs": {
    "top-ingredients":{
      "terms": {
        "field": "ingredients.name.keyword",
        "size": 10,
        "missing": "N/A",
        "min_doc_count": 0,
        "order": {
          "_count": "asc"
        }
      }
    }
  }
}

GET recipes/_mapping
#sub aggregations
#metric aggregation within bucket aggregation
GET recipes/_search
{
  "size": 0,
  "_source": [
    "title",
    "ingredients.name"
  ],
  "aggs": {
    "top-ingredients": {
      "terms": {
        "field": "ingredients.name.keyword",
        "size": 10
      },
      "aggs": {
        "avg-rating": {
          "avg": {
            "field": "preparation_time_minutes"
          }
        }
      }
    }
  }
}

GET tmdb/_mapping

#bucket within bucket
GET tmdb/_search
{
  "size": 0,
  "aggs": {
    "most-released-month": {
      "terms": {
        "field": "release_date"
      },
      "aggs": {
        "max-revenue": {
          "max": {
            "field": "revenue"
          }
        },
        "poster-paths": {
          "terms": {
            "field": "poster_path.keyword",
            "size": 1
          }
        }
      }
    }
  }
}

GET recipes/_count
{"query":{ "match":{"title":"pasta"}}}

#filter in aggregations
#1st filter and then create sub aggs. Filter and aggs are siblings
GET recipes/_search
{
  "size": 0,
  "query": {
    "range": {
      "ratings": {
        "gte": 5
      }
    }
  },
  "_source": [
    "title",
    "ingredients.name"
  ],
  "aggs": {
    "prep-time-stats-of-all-dishes": {
      "stats": {"field": "preparation_time_minutes"}
    },
    "pasta-filter": {
      "filter": {"match": {"title": "pasta"}},
      "aggs": {
        "top-ingredients": {"terms": {"field":"ingredients.name.keyword", "size": 2}},
        "min-prep-time":{"min": {"field": "preparation_time_minutes"}}
      }
    }
  }
}

#bucket rules with filters (multiple filters)
GET recipes/_search
{
  "size": 0,
  "query": {
    "range": {
      "ratings": {
        "gte": 5
      }
    }
  },
  "_source": [
    "title",
    "ingredients.name"
  ],
  "aggs": {
    "dish-categories": {
      "filters": {
        "filters": {
          "pastas": {
            "match": {
              "title": "pasta"
            }
          },
          "ricottas": {
            "match": {
              "title": "ricotta"
            }
          }
        }
      },
      "aggs": {
        "top-ingredients": {
          "terms": {
            "field": "ingredients.name.keyword",
            "size": 2
          }
        },
        "min-prep-time": {
          "min": {
            "field": "preparation_time_minutes"
          }
        }
      }
    }
  }
}

 
#range aggregations
# format, keyed, key, bucket stats
GET tmdb/_search
{
  "size": 0,
  "_source": {
    "excludes": [
      "overview",
      "cast"
    ]
  },
  "aggs": {
    "release-distribution-over-years": {
      "range": {
        "field": "release_date",
        "format": "yyyy-MM-dd",
        "ranges": [
          {
            "from": "1996-01-01",
            "to": "1996-01-01||+5y",
            "key": "2nd half of 20th century"
          },
          {
            "from": "1996-01-01||+10y",
            "to": "1996-01-01||+15y",
            "key": "1st half of 21st century"
          },
          {
            "from": "1996-01-01||+15y",
            "to": "1996-01-01||+20y",
            "key": "2nd half of 21st century"
          }
        ],
        "keyed": true
      },
      "aggs": {
        "sum-revenue": {
          "sum": {
            "field": "revenue"
          }
        }
      }
    }
  }
}



#histogram
# extended bounds is not used for filtering, it will only add fillers when documents are empty and force ES to add those buckets
# other units of calendar is not supported say 5y
GET tmdb/_search
{
  "size": 0,
  "aggs": {
    "movie-release-date-histogram": {
      "date_histogram": {
        "field": "release_date",
        "calendar_interval": "year",
        "format": "yyyy-MM-dd",
        "keyed": true,
        "min_doc_count": 0, 
        "extended_bounds": {
          "min": "2015-01-01",
          "max": "2031-01-01"
        }
      },
      "aggs": {
        "avg-rating": {
          "avg": {
            "field": "vote_average"
          }
        }
      }
    }
  }
}

GET tmdb/_mapping/field/release_date
GET tmdb/_search
{
  "size": 0,
  "aggs": {
    "movie-rating-histogram": {
      "histogram": {
        "field": "vote_average",
        "interval": 1,
        "keyed": true,
        "min_doc_count": 0,
        "extended_bounds": {
          "min": "0",
          "max": "10"
        }
      },
      "aggs": {
        "most-released-year": {
          "date_histogram": {
            "field": "release_date",
            "format": "yyyy", 
            "calendar_interval": "year",
            "min_doc_count": 5,
            "keyed": true, 
            "order": {
              "_count": "desc"
            }
          }
        }
      }
    }
  }
}

#global aggregation
GET recipes/_search
{
  "size": 0,
  "query": {
    "range": {
      "ratings": {
        "gte": 5
      }
    }
  },
  "_source": [
    "title",
    "ingredients.name"
  ],
  "aggs": {
    "total-ingredients":{
      "cardinality": {
        "field": "ingredients.name.keyword"
      }
    },
    "recipes-with-all-ratings": {
      "global": {},
      "aggs": {
        "total-ingredients": {
          "cardinality": {
            "field": "ingredients.name.keyword"
          }
        }
      }
    }
  }
}


#missing - how does it differ from count using must_not exists
GET recipes/_search
{
  "size": 0,
  "aggs": {
    "recipes-with-no-ingredients": {
      "missing": {
        "field": "ingredients.name.keyword"
      }
    }
  }
}

#nested aggregations
#aggregation is applied on matching 1 department and not on the matching employees
GET department/_search
{
  "_source": "false",
  "query": {
    "nested": {
      "path": "employees",
      "inner_hits": {
        
      },
      "query": {
        "match": {
          "employees.position": "lecturer"
        }
      }
    }
  },
  "aggs": {
    "employee-aggs": {
      "nested": {
        "path": "employees"
      },
      "aggs": {
        "gender-count": {
          "terms": {
            "field": "employees.gender.keyword"
          },
          "aggs": {
            "age-stats": {
              "stats": {
                "field": "employees.age"
              }
            }
          }
        }
      }
    }
  }
}


#=======================Improving search results=================
PUT search-relevance-test/_doc/1
{ "name": "Potato salad is the best one", "description": "its a good one"}
PUT search-relevance-test/_doc/2
{ "name": "Greek salad", "description": "this salad is good for dieting"}
PUT search-relevance-test/_doc/3
{ "name": "Potato fries goes well with burger", "description": "well the name says it all"}
PUT search-relevance-test/_doc/4
{ "name": "Fries (potato)", "description": "well the name says it all"}
PUT search-relevance-test/_doc/5
{ "name": "Potato salad and french fries", "description": "well the name says it all"}
PUT search-relevance-test/_doc/6
{ "name": "Beef goulash", "description": "famous in prague"}
PUT search-relevance-test/_doc/6
{ "name": "Agli o elio", "description": "famous in italy"}



#matches sequence of words
# wouldn't match fries potato
GET search-relevance-test/_search
{
  "query": {
    "match_phrase": {
      "name": {
       "query": "potato fries"
      }
    }
  }
}

# proximity
#"potato fries"
#"potato|fries "step 1
#"fries potato" step 2
#"fries <word> potato" step 3
# we can use match query for this, match phrase is used just to boost the proximity
# note how doc 3 "Potato fries goes..." is scored low with match query whereas with match phrase its scored high due to proximity
GET search-relevance-test/_search
{
  "query": {
    "match_phrase": {
      "name": {
       "query": "potato fries",
       "slop": 3
      }
    }
  }
}

GET search-relevance-test/_search
{
  "query": {
    "match": {
      "name": {
       "query": "potato fries"
      }
    }
  }
}

#the above can also be achieved using should query to boost relevance
GET search-relevance-test/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "name": {
              "query": "potato fries"
            }
          }
        }
      ],
      "should": [
        {
          "match_phrase": {
            "name": {
              "query": "potato fries",
              "slop": 3
            }
          }
        }
      ]
    }
  }
}

#termlength & edit distance 
# 1-2 , 0
# 3-5 , 1
# >5 2
# Higher the fuzziness, more irrelevant and costlier the operations would be
# best to leave to auto
GET search-relevance-test/_search
{
  "query": {
    "match": {
      "name": {
        "query":"potato"
      }
    }
  }
}

# fuzziness value is per term
# there are two terms, 1 edit per term, in total 2. With fuzziness value 1, it starts matching instead of 2. so value is per term
GET search-relevance-test/_search
{
  "query": {
    "match": {
      "name": {
        "query": "fotato falad",
        "operator": "and",
        "fuzziness": 1
      }
    }
  }
}

#fuzziness transposition - switch of nearby letters with edit distance 1.
#without this edit distance would be 2
# aslad - step1 a|s lad - step 2 salad without transposition
GET search-relevance-test/_search
{
  "query": {
    "match": {
      "name": {
        "query": "aslad",
        "fuzziness": 1,
        "fuzzy_transpositions": "false"
      }
    }
  }
}

GET search-relevance-test/_search
{
  "query": {
    "match": {
      "name": {
        "query": "fotato aslad",
        "operator": "and", 
        "fuzziness": 2,
        "fuzzy_transpositions": "false"
      }
    }
  }
}

#fuzzy query
#fuzzy query is the term level query, not analyzed, converting case is also considered edits.
#match query is the full text query
#prefer match query with fuzziness parameter
GET search-relevance-test/_search
{
  "query": {
    "fuzzy": {
      "name": {
        "value": "fOTato",
        "fuzziness": "auto"
      }
    }
  }
  
}

#synnonyms
# check case - depends on order of filters specified
# multi terms
#try search with both source and replacement word
#file

#highlighter 
# plane highlighter
#pre_tags post_tags
#try multiple fields

#stemming

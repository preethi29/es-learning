GET _cluster/health
GET _cat/indices?v
GET _cat/nodes?v
GET _cat/shards?v
GET _cat/shards/tmdb-new
GET _cat/recovery

#splitting
PUT tmdb-new/_settings
{
  "settings":{
    "index.blocks.write": true
  }
}

PUT tmdb-new/_split/tmdb-split-2
{
  "settings":{
    "index.number_of_shards": 4
  }
}

#reindexes
POST tmdb-new/_update_by_query
#merges segments
POST tmdb-new/_forcemerge
DELETE tmdb-scaled-2

GET tmdb-scaled/_settings
GET tmdb/_settings
GET tmdb-new/_settings
#shrinking
# make sure all the source index's shards are in the same node and its is read only
PUT /tmdb-scaled/_settings
{
  "settings": {
    "index.number_of_replicas": 0,                                
    "index.routing.allocation.require._name": "preethi-sadagopan", 
    "index.blocks.write": true                                    
  }
}

# shrink it now
PUT tmdb-scaled/_shrink/tmdb-new
{
  "settings":{
        "index.number_of_replicas": 1,
    "index.number_of_shards": 1, 
    "index.codec": "best_compression"
  
  }
}

GET _cluster/health/tmdb-sc?wait_for_no_relocating_shards=true

PUT /tmdb-new/_settings
{
  "settings": {
    "index.number_of_replicas": 2,
    "index.routing.allocation.require._name": null
  }
}

# make node ineligbile for voting, this is done when shutting down 1 node when there are only 2 nodes in the cluster
POST /_cluster/voting_config_exclusions?node_names=node-3


#create snapshot repository
PUT /_snapshot/tmdb-backup
{
  "type": "fs",
  "settings": {
    "location": "/usr/local/var/lib/elasticsearch/backups"
  }
}

#take snapshot
PUT /_snapshot/tmdb-backup/snapshot_1?wait_for_completion=true
{
  "indices": "tmdb,tmdb-new",
  "ignore_unavailable": true,
  "include_global_state": false,
  "metadata": {
    "taken_by": "Preethi",
    "taken_because": "backup before upgrading"
  }
}

#restore snapshot
POST /_snapshot/tmdb-backup/snapshot_1/_restore
{
  "indices": "tmdb",
  "ignore_unavailable": true,
  "include_global_state": false,              
  "rename_pattern": "tmdb",
  "rename_replacement": "tmdb-restored",
  "include_aliases": false
}

GET /tmdb-restored/_count


#create doc with autogenerated id
POST products/_doc
{
  "name": "dalda"
}

#will replace the entire doc with given object or creates a doc with this id
PUT products/_doc/1
{
  "name": "tata salt"
}
GET products/_search

#update certain fields of the doc and will fail if no doc exists with the given id
POST products/_update/1
{
  "doc": {
    "name": "tata iodine salt",
    "price": 15
  }
}

POST products/_doc/2
{
  
    "name": "levista instant coffee",
    "price": 6
  
}

#scripted updates
# with params
POST products/_update/1
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }
    """,
    "params": {
      "inflation_value": 4
    }
    
  }
}

#with noop - notice that version is not increased when noops but otherwise increased even without change
POST products/_update/2
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }else{
       ctx.op = "noop"
     }
    """,
    "params": {
      "inflation_value": 4
    }
    
  }
}

#with ops as delete - this will delete the doc. in real life, it is not useful since you can always use delete by query
POST products/_update/2
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }else{
       ctx.op = "delete"
     }
    """,
    "params": {
      "inflation_value": 4
    }
    
  }
}

#Upserts
#will update only given values if doc is present or will create a new doc with object given in upsert section
POST products/_update/4
{
  "script": {
    "source": """
     if(ctx._source.price >= 15.00){
       ctx._source.price += params.inflation_value
     }else{
       ctx.op = "noop"
     }
    """,
    "params": {
      "inflation_value": 4
    }
  },
  "upsert": {
    "name": "pazham pori",
    "price": 2,
    "ingredients": [
      "kadalai mavu",
      "nendra pazham"
    ]
  }
}

DELETE products/_doc/4

GET products/_doc/5

# Primary term and Sequence Number - Optimistic concurrency control
#	Each doc can have different primary term and sequence number
#		doc1 - pt 1 sn 1 (update doc1)
#		doc2 -pt 1 sn 2 (update doc2)
#		doc1 - pt 1 sn 3 (update doc1)
#		doc2 - pt1 sn 4 ( this request would go through with concurrency control only if if_primary_term=1&if_seq_no=2 (would fail if if_seq_no=3)
#	basically these values are incremented across write operations but used for concurrency check at doc level
POST products/_doc/5?if_primary_term=1&if_seq_no=43
{
  "name": "nei appam",
  "price": 7.56
}

GET tmdb-restored/_doc/9779

POST tmdb-restored/_update/9779
{
  "doc":{
  "rotten_tomatoes_rating": 1000
  }
}

#update by query
# 1 batch = 1000 docs by default
POST tmdb-restored/_update_by_query
{
  "script": {
    "source": "ctx._source.rotten_tomatoes_rating = ctx._source_vote_average"
  },
  "query": {
    "match_all": {}
  }
}

#delete by query
POST tmdb-restored/_delete_by_query
{
  "query":{
    "match":{
        "_id": 9779

    }
  }
}

#bulk apis - timeout is set at request level i guess
POST products/_bulk
{ "create": {"_id": 6}}
{ "name": "saunf", "price": 10}
{ "index": { "_id": 7}}
{ "name": "cashew", "price": 50}
{ "create": { "_id": 7}}
{ "name": "cashew 2", "price": 50}
{ "update": { "_id": 7}}
{ "doc": {"name": "cashew kaju", "price": 50}}
{ "delete": { "_id": 1}}

GET products/_doc/7

